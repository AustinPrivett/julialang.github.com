---
layout: post
title:  "Upgrades to the REPL in v0.6"
author: <a href="https://kristofferc.github.io/">Kristoffer Carlsson</a>
---

Since v0.3, Julia comes with a REPL completely written in Julia ([PR #6270](https://github.com/JuliaLang/julia/pull/6270)).
Among other features, the REPL provides code completion, history with reverse search, a rich set of keybindings which in addition are customizable. (See the [Interacting with Julia](http://docs.julialang.org/en/stable/manual/interacting-with-julia/) part of the manual for the REPL documentation.)
Even so, v0.6 of Julia comes with quite a few new visual tweaks and feature upgrades over v0.5.
In this blog post, we look into some of these changes and customizations to the Julia REPL, available in v0.6.

## Prompt pasting

It is quite common (as in the Julia manual and in subsequent code blocks of this blog post) to write snippets of Julia code like they were copied straight from a REPL session, for example:

```julia
julia> f() = rand(10^6)
f (generic function with 1 method)

julia> @time f();
  0.052948 seconds (25.05 k allocations: 8.769 MiB)
```

If you wanted to try out this code in v0.5, you would typically copy the code into a text editor, remove the `julia> ` prompt, remove the output, and then finally have code that looked like:

```julia
f() = rand(10^6);

@time f();
```

which could then be pasted back into the REPL to be executed.
In v0.6, the REPL comes with a feature called *prompt pasting* by which a pasted expression starting with `julia> ` automatically has prompts and eventual output scrubbed before being executed.
If you have a v0.6 REPL currently at hand, you can try to copy and paste the example with the prompt and output above directly into the REPL and you will see that it works in exactly the same way as if we had manually removed them.

Unfortunately, for technical reasons (no support for bracket pasting), this feature does not work in the standard cmd-terminal on Windows.
There are however multiple alternative terminal emulators on Windows that do support this, e.g. [Console2](https://sourceforge.net/projects/console/) or [Cygwin](https://www.cygwin.com/).

## Printing of stacktraces

The accuracy of the stacktraces getting printed when an error is thrown is improved in every release.
Function calls are now even tracked through inlining so that often the full chain of calls up to the error is shown.
This, combined with the Julia idiom of breaking complex tasks across many smaller functions that perform simpler tasks, makes for potentially deep stacktraces.
In addition, types in Julia can easily become verbose to print since it is so easy to make types taking many type parameters (see for example `StridedArray`).
Thus, stacktraces in Julia tend to be deep and each stackframe takes a significant amount of space when printed.

In earlier julia versions, stacktraces were being printed without much structure.
Everything was printed in bold red which made it a bit difficult to find the information one was looking for.
As an example, here is a screenshot from an error thrown on 0.5:

![Stacktrace in 0.5](https://github.com/JuliaLang/julialang.github.com/blob/master/blog/_posts/repl0.6/0.5stacktrace.png)

Finding the relevant information can be quite difficult, especially the file name and line numbers since they are not aligned in any way.
In 0.6, this is what is currently showen for the same error:

![Stacktrace in 0.6](https://github.com/JuliaLang/julialang.github.com/blob/master/blog/_posts/repl0.6/0.6stacktrace.png)

We stopped printing the contents of the `Array` on a `BoundsError` but more relevant for this section, the way stacktraces are shown is significantly different.
They are no longer written in bold red, which helps distinguish it from the error message and the parts that are most likely to be interesting (the function name and the line info) are now bold, making them stick out from the surrounding text.
Every stackframe is also numbered which makes them easier to refer to.
Furthermore, is is now possible to customize the colors that the functions and line infos are printed with.
This is done by setting the environment variables `JULIA_STACKFRAME_FUNCTION_COLOR` and `JULIA_STACKFRAME_LINEINFO_COLOR` respectively.
Executing:

```julia
julia> ENV["JULIA_STACKFRAME_LINEINFO_COLOR"] = :cyan;

julia> ENV["JULIA_STACKFRAME_FUNCTION_COLOR"] = :yellow;
```

and rerunning the example, now displays:

![Stacktrace in 0.5 with configured colors](https://github.com/JuliaLang/julialang.github.com/blob/master/blog/_posts/repl0.6/0.6stacktrace_conf.png)

In addition to the visual changes of the stacktrace, there is also a new interactive feature, possible now that we can refer to stackframes by number.
After a stacktrace has been printed, you can simply enter the number of one of the stack frames in the REPL, press `CTRL + Q` and the file will be opened in
the editor at the file and line number relevant to that stackframe.
To set the editor, use the environment variable `EDITOR`, for example `ENV["EDITOR"] = "subl"` for the Sublime Text editor.
This can be used when you quickly want to fix a typo or just to jump around with the editor in the call stack leading up to the error.

Note that it is currently not possible to open a piece of code defined in the REPL in an editor.

## More colors

In v0.5, it was possible to use 8 colors for printing (see `help?> Base.text_colors`) by using the function `print_with_color`, which  unconditionally wrote the colored text in bold.
In 0.6, light versions of these colors (prefixed by `light_`) are also supported, increasing the number of named colors to 16.
In addition, an integer between 0 and 255 can now be used as a color (see [this chart](https://commons.wikimedia.org/wiki/File:Xterm_256color_chart.svg) for a reference).
These new colors are possible to use wherever an option previously existed to change the color of some element in the REPL.
Another change is that by default, the function `print_with_color` no longer prints in bold.
Instead a new keyword argument `bold::Bool` determines if the text is printed in bold or not.

Some examples of this functionality are given in the figure below:

![Colors in 0.6](https://github.com/JuliaLang/julialang.github.com/blob/master/blog/_posts/repl0.6/0.6colors.png)

## Default style of input/output text

Previously, the default style of entered code and shown objects in the REPL was bold.
In v0.6, the decision was made to change this to unstyled (non bold) text.
It is however possible to change this back to bold, or to any other color:

![Colors in 0.6](https://github.com/JuliaLang/julialang.github.com/blob/master/blog/_posts/repl0.6/0.6input_output_conf.png)


## Taking REPL-customization even further

If you would like to take the REPL customization even further, I would recommend taking a look at the [`OhMyREPL`](https://github.com/KristofferC/OhMyREPL.julia) package (author of this blog post is also author of that package).
Most of the features described in this blog post were upstreamed to Base Julia from that package, but for now, some more advanced features, like syntax highlighting, matching bracket highlighting and customization of input/output prompts, still live in that package.